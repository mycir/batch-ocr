#!/bin/bash

# shellcheck disable=SC2181

shopt -s extglob

TITLE_BASE="Batch OCR"
# scan preview window - percentage of dekstop
# suits display scaling up to say 125%
# adjust to suit for higher scale factors
PREVIEW_MAX_X=70
PREVIEW_MAX_Y=95
PREVIEW_ORIGIN_X=6
PREVIEW_ORIGIN_Y=6
EOG_SPACER=2

declare -A job_settings
declare -A default_options
declare -a default_options_keys
declare -A scan_options
declare -a scanimage_options
declare -a magick_options

index=1
resume=false

awk_scanner_options=$(cat <<'EOF'
# Parse scanimage -A -d <device> output for typical airscan/escl options.
# Can be overidden if it returns junk with other types of scanner -
# see sample 'epson.options' file for info.
/--resolution / { printf "resolution=resolution:list:%s:%s:Resolution\n", 
                    get_list(3), get_default() }
/--mode / { printf "mode=mode:list:%s:%s:Mode\n",
                    get_list(), get_default() }
/--brightness / { printf "brightness=brightness:range:%s:%s:Brightness\n",
                    get_range(), get_default() }
/--contrast / { printf "contrast=contrast:range:%s:%s:Contrast\n",
                    get_range(), get_default() }
/--analog-gamma / { printf "gamma=analog-gamma:range:%s:%s:Gamma\n",
                        get_range(), get_default() }

function get_range() {
    match($0, /-*[0-9.]+/)
    r=substr($0, RSTART, RLENGTH)
    return r
}

function get_list(rtrim) {
    match($0, /([^ ]+\|)+[^ ]+/)
    l=substr($0, RSTART, RLENGTH - rtrim)
    return l
}

function get_default() {
    match($0, /\[.*\]/)
    d=substr($0, RSTART + 1, RLENGTH - 2)
    return d
}
EOF
)

awk_xsane=$(cat <<'EOF'
{
    if (FNR == 1) {
        if (matched) {
            exit
        }
        matched = 0
    }
    else if (FNR == 2 && $0 ~ tgt) {
            matched = 1
            next
        } else if (matched) {
            if ( /"(resolution|mode)"/) {
                split($0, arr, /"/)
                key = arr[2]
                getline
                printf "%s=%s ", key, $1
            } else if ( /"xsane-(gamma|brightness|contrast)"/) {
                split($0, arr, /[-"]/)
                key = arr[3]
                getline
                printf "%s=%.2f ", key, $1 / 65536
            }
        }
}
EOF
)

get_window_id () {
    id=$(wmctrl -l -x | awk -v c="$1" -v t="$2" '{
            class_match = (c == "" || $3 ~ c)
            title_match = (t == "" || $5 ~ t)
            if (class_match && title_match) {
                print $1
                exit
            }
        }
        END { if (!class_match || !title_match) print 0 }')
    echo "$id"
}

get_window_geometry () {
    read -r x y width height <<<"$(xwininfo -id "$1" | awk '
        /Absolute upper-left X:/ {x = $4}
        /Absolute upper-left Y:/ {y = $4}
        /Width:/ {w = $2}
        /Height:/ {h = $2}
        END {print x, y, w, h}')"
    frame_extents=$(xprop -id "$1" _GTK_FRAME_EXTENTS | \
        awk -F'[/=|,]' '{print $2 $3 $4 $5}')
    [[ $frame_extents = "" ]] && frame_extents="0 0 0 0"
    echo "$x $y $width $height $frame_extents"
}

get_true_geometry () {
    read -r x y w h fx_l fx_r fx_t fx_b < <(get_window_geometry "$1")
    true_x=$((x + fx_l))    
    true_y=$((y + fx_t))    
    true_w=$((w - fx_l - fx_r))    
    true_h=$((h - fx_t - fx_b))    
    echo $true_x $true_y $true_w $true_h
}

define_preview_geometry () {
    read -r x y w h fx_l fx_r fx_t fx_b < <(get_window_geometry "$1")
    new_x=$(( working_area_width * PREVIEW_ORIGIN_X / 100 - fx_l ))
    new_y=$(( working_area_height * PREVIEW_ORIGIN_Y / 100 - fx_t ))
    new_w=$(( working_area_width * PREVIEW_MAX_X / 100 - fx_l - fx_r ))
    new_h=$(( working_area_height * PREVIEW_MAX_Y / 100 - fx_t - fx_b ))
    echo $new_x $new_y $new_w $new_h
}

arrange_window () {
    while true; do
        # shellcheck disable=SC2086
        id=$(get_window_id $1 $2)
        (( id )) && break
        sleep 0.05
    done
    wmctrl -i -a "$id"
    case $stage in
        "$UI_GRIDVIEW")
            read -r x y w h < <(define_preview_geometry "$id")
            wmctrl -i -r "$id" -e 0,"$x","$y","$w","$h"
            ;;
        "$DLG_CROP" | "$DLG_APPROVE")
            eog_id=$(get_window_id "batch_ocr.Eog")
            read -r eog_x eog_y eog_w _ < <(get_true_geometry "$eog_id")
            read -r _ _ _ _ fx_l _ fx_t _ < <(get_window_geometry "$id")
            separation=$((working_area_width * EOG_SPACER / 100))
            new_x=$((eog_x + eog_w - fx_l + separation))
            new_y=$((eog_y - fx_t))
            wmctrl -i -r "$id" -e 0,$new_x,$new_y,-1,-1
            ;;
        *)
            # centre dialogs in the case of tiling window managers
            read -r _ _ w h fx_l fx_r fx_t fx_b < <(get_window_geometry "$id")
            x=$((working_area_centre_x - (w - fx_l - fx_r) / 2 - fx_l))
            y=$((working_area_centre_y - (h - fx_t - fx_b) / 2 - fx_t))
            wmctrl -i -r "$id" -e 0,$x,$y,-1,-1
            ;;
    esac
}

get_last_scan_info () {
    f=$(find "$1" -maxdepth 1 \
        \( -name "*.tiff" -o -name "*.jpeg" -o -name "*.png" -o -name "*.pnm" \) \
        -exec basename {} \; | sort -hr | head -1)
    if (( ! $? )) ; then
        no_prefix=${f#"${job_settings[prefix]}-"}
        i=${no_prefix%%[-|\.]*}
        i=$((10#$i))
        echo "$i:$f"
    fi
}

set_default_job_settings () {
    job_settings[prefix]=scan
    job_settings[suffix]="Index number"
    job_settings[images_type]=tiff
    job_settings[rotation]=-90
    job_settings[split_pages]=true
    job_settings[pdf_output]="Combined PDF"
    job_settings[text_output]=None
    job_settings[hocr_output]=None
    job_settings[ocr_language]=eng
    job_settings[ocr_layout]=Auto
    job_settings[page_size]=a4
    job_settings[save_scan_settings]="Only for this job"
    job_settings[crop]=":::::"
}

fetch_job_settings () {
    while IFS='=' read -r k v; do
        [[ $k != "" ]] && job_settings[$k]="$v"
    done  < <(cat "$1")
}

save_job_settings () {
    local s
    for k in \
        output_dir prefix suffix images_type rotation \
        split_pages save_scan_settings pdf_output text_output  \
        hocr_output ocr_language ocr_layout page_size crop; do
        s+="$k=${job_settings[$k]}\n"
    done
    echo -e "$s" > "${job_settings[output_dir]}/job-settings"
}

read_scan_options () {
    while read -r line; do
        [[ $line =~ ^[[:space:]]*#|^[[:space:]]*$ ]] && continue
        k=${line%%"$1"*}
        v=${line#*"$1"}
        default_options["$k"]="$v"
        default_options_keys+=("$k")
        scan_options["$k"]=$(get_scan_option "$k" "default")
    done
    if ! [[ -v default_options[mode] ]] ; then
        default_options[mode]=":list:HSL|Gray:HSL:Mode"
        default_options_keys+=("mode")
        scan_options[mode]="HSL"
    fi
    if ! [[ -v default_options[gamma] ]] ; then
        default_options[gamma]=":range:0.8..2.3:1.0:Gamma"
        default_options_keys+=("gamma")
        scan_options[gamma]="1.0"
    fi
    if ! [[ -v default_options[brightness] ]] ; then
        default_options[brightness]=":range:-100..100:0:Brightness"
        default_options_keys+=("brightness")
        scan_options[brightness]="0"
    fi
    if ! [[ -v default_options[contrast] ]] ; then
        default_options[contrast]=":range:-100..100:0:Contrast"
        default_options_keys+=("contrast")
        scan_options[contrast]="0"
    fi
}

fetch_scan_settings () {
    local f k v
    if [ -e "${job_settings[output_dir]}/$device.scan-options" ] ; then
        f="${job_settings[output_dir]}/$device.scan-options"
    elif [ -e "$bocr_dir/$device.scan-options" ] ; then
        f="$bocr_dir/$device.scan-options"
    fi    
    if [ -v f ] ; then
        while IFS='=' read -r k v; do
            [ -n "$v" ] && scan_options["$k"]="$v"
        done  < <(cat "$f")
    elif [ -e ~/.sane/xsane ]; then
        read -r -a sets \
            < <(awk -v tgt="$name" "$awk_xsane" ~/.sane/xsane/*.drc)
        for i in "${!sets[@]}" ; do
            k=${sets[$i]%%=*}
            v=${sets[$i]##*=}
            scan_options["$k"]=$v
        done
    fi
}

save_scan_settings () {
    local s
    for (( i=0; i < ${#default_options_keys[@]}; i++ )) ; do
        key="${default_options_keys[$i]}"
        s+="$key=${scan_options[$key]}\n"
    done
    echo -e "$s" > "$1/$device.scan-options"
}

get_scan_option () {
    IFS=":" read -r option type data default label  < <(echo "${default_options[$1]}")
    if [[ -n $2 ]] ; then
        local fields ; for w in $2 ; do fields+="${!w} " ; done ; echo "${fields% }"
    else
        echo "$option $type $data $default $label "
    fi
}

add_command_option () {
    opt=$(get_scan_option "$1" "option")
    if [[ "$opt" != "" ]] ; then
        scanimage_options+=( "--$opt" "$2" ) 
    else
        case $1 in
            "mode")
                magick_options+=( "-colorspace" "$2" )
                ;;
            "gamma")
                magick_options+=( "-gamma" "$2" )
                ;;
            "brightness")
                brightness="$2"
                ;;
            "contrast")
                ! [[ -v brightness ]] && brightness=0
                magick_options+=( "-brightness-contrast" "${brightness}x$2" )
                ;;
        esac
    fi
}

sanitise () {
    echo "$1" | \
        awk '/^-/ { minus="-" } { gsub(/[^0-9.]/,"") ; len = split($0, a, ".")
            if (len == 1) print ; else printf "%s%s.%s", minus, a[1], a[2] }' -
}

space_chars () {
    chrs=$( echo "$1" | \
        awk '{for(i = 1; i <= length($0); i++) printf "%s ", substr($0, i, 1)}')
    chrs=${chrs//-/minus}
    chrs=${chrs//./period}
    chrs=${chrs//  / space}
    echo "$chrs"
}

shift_tab_sequence () {
    local sequence
    for (( i=1; i <= $1; i++ )) ; do sequence+=" shift+Tab"; done
    echo "$sequence"
}

prepare_dialog () {
    name=$2
    local sequence
    # if Wayland and GDK_BACKEND=x11, first few keys sent may be lost,
    # so send a few do nothing keys
    ! [[ -v BOCR_XDOTOOL_DELAY ]] && sequence="key ctrl ctrl ctrl " ||
        sequence="key --delay $BOCR_XDOTOOL_DELAY ctrl ctrl ctrl " 
    case "$1" in
        "$DLG_FILEBASE")
            sequence+="$(space_chars "${job_settings[prefix]}") Tab Tab \
                $(space_chars "$index") $(shift_tab_sequence 2)"
            ;;
        "$DLG_OPTIONS")
            sequence+="Tab Tab "
            for (( i=0; i < ${#default_options_keys[@]}; i++ )) ; do
                k=${default_options_keys[$i]}
                fields=$(get_scan_option "$k" "type default")
                type=${fields%% *}
                if [[ $type =~ range|value  ]] ; then
                    v=${scan_options["$k"]}
                    # shellcheck disable=SC2086
                    sequence+="$(space_chars \
                        "$(printf '%.2f\n' $v)") Tab "
                else
                    sequence+="Tab "
                fi
            done
            sequence+="$(shift_tab_sequence $(( i + 2 )))"
            ;;
        "$DLG_CROP")
            local -A pcts
            IFS=':' read -r pcts["pg1_left_crop"] pcts["pg1_right_crop"] \
                pcts["pg2_left_crop"] pcts["pg2_right_crop"] \
                pcts["top_crop"] pcts["bottom_crop"] < <(echo "${job_settings[crop]}")
            sequence+="
                $(space_chars "${pcts[pg1_left_crop]}") Tab \
                $(space_chars "${pcts[pg1_right_crop]}") Tab \
                $(space_chars "${pcts[pg2_left_crop]}") Tab \
                $(space_chars "${pcts[pg2_right_crop]}") Tab \
                $(space_chars "${pcts[top_crop]}") Tab \
                $(space_chars "${pcts[bottom_crop]}") \
                $(shift_tab_sequence 5)"
            ;;
        *) name="$TITLE_BASE" ;;
    esac
    # shellcheck disable=SC2086
    xdotool search --sync --onlyvisible --name "$name" \
        windowfocus --sync $sequence
}

build_combo_values () {
    cv="$2|${1/$2/}"
    cv="${cv/||/|}"
    cv=${cv%|} 
    echo "$cv"
}

build_combo_langs () {
    default=${job_settings[ocr_language]}
    langs=$(tesseract --list-langs | tail -n +2)
    cv="$default|"
    for l in ${langs%"$default"*}${langs#*"$default"} ; do
        cv+="$l|"
    done
    echo "${cv%*|}"
}

build_combo_page_sizes () {
    default=${job_settings[page_size]}
    ps=$(get_page_sizes)
    cv="$default|"
    for s in ${ps/$default/} ; do  cv+="$s|" ; done
    echo "${cv%*|}"    
}

get_page_sizes () {
    find /usr/share/ghostscript -name gs_statd.ps 2>/dev/null | \
        while read -r f; do awk '
            BEGIN { in_list = 0 }
            /\/\.pagetypeprocs/ { in_list = 1; next }
            /currentdict end/ { in_list = 0 }
            in_list && /^(\s|[^%])*\/[a-zA-Z0-9]+/ {
                gsub("/", "", $1);print $1
            } ' "$f"; done | sort -u
}

crop_page () {
    read -r w h < <(identify -format "%w %h" "$1")
    (( $3 )) && read -r w h <<<"$h $w"
    local -A pcts
    IFS=':' read -r pcts["left_crop"] pcts["right_crop"] \
        pcts["top_crop"] pcts["bottom_crop"] < <(echo "${job_settings[crop]}")
    for pct in "${!pcts[@]}" ; do
        pcts[$pct]=${pcts[$pct]:-0}
    done
    pixels_pct_x=$(( w / 100 ))
    pixels_pct_y=$(( h / 100 ))
    left_crop_pixels=$(( pixels_pct_x * "${pcts['left_crop']}"))
    right_crop_pixels=$(( w - "${pcts['right_crop']}" * pixels_pct_x ))
    top_crop_pixels=$(( pixels_pct_y * "${pcts['top_crop']}"))
    bottom_crop_pixels=$(( pixels_pct_y * "${pcts['bottom_crop']}"))
    $convert "$1" -rotate "${job_settings[rotation]}" \
        -crop +$left_crop_pixels+$top_crop_pixels \
        -crop -$(( w - right_crop_pixels ))+$top_crop_pixels \
        -crop +0-$bottom_crop_pixels +repage "$2"
    echo "$2"
}

crop_pages () {
    read -r w h < <(identify -format "%w %h" "$1")
    (( $4 )) && read -r w h <<<"$h $w" 
    local -A pcts
    IFS=':' read -r pcts["pg1_left_crop"] pcts["pg1_right_crop"] \
        pcts["pg2_left_crop"] pcts["pg2_right_crop"] \
        pcts["top_crop"] pcts["bottom_crop"] < <(echo "${job_settings[crop]}")
    for pct in "${!pcts[@]}" ; do
        pcts[$pct]=${pcts[$pct]:-0}
    done
    pixels_pct_x=$(( w / 100 ))
    pixels_pct_y=$(( h / 100 ))
    centre_px_x=$(( w / 2 ))
    pg1_left_pixels=$(( pixels_pct_x * "${pcts['pg1_left_crop']}"))
    pg1_right_pixels=$(( centre_px_x - "${pcts['pg1_right_crop']}" * pixels_pct_x ))
    pg2_left_pixels=$(( centre_px_x + "${pcts['pg2_left_crop']}" * pixels_pct_x ))
    pg2_right_pixels=$(( w - "${pcts['pg2_right_crop']}" * pixels_pct_x ))
    top_crop_pixels=$(( pixels_pct_y * "${pcts['top_crop']}"))
    bottom_crop_pixels=$(( pixels_pct_y * "${pcts['bottom_crop']}"))
    $convert "$1" -rotate "${job_settings[rotation]}" \
        -crop +$pg1_left_pixels+$top_crop_pixels \
        -crop -$(( w - pg1_right_pixels ))+$top_crop_pixels \
        -crop +0-$bottom_crop_pixels +repage "$2"
    $convert "$1" -rotate "${job_settings[rotation]}" \
        -crop +$pg2_left_pixels+$top_crop_pixels \
        -crop -$(( w - pg2_right_pixels ))+$top_crop_pixels \
        -crop +0-$bottom_crop_pixels +repage "$3"
    echo "$2"
}

start_progress_dialog () {
    coproc pd { zenity --progress --title="$TITLE_BASE" \
        --text "$text1\n$text2" \
        --time-remaining --percentage=0 --auto-close ;
        (( $? )) && pkill tesseract.*~  ; }
    arrange_window zenity "$TITLE_BASE"
    exec {progress_dlg_in}>&"${pd[1]}"
    export progress_dlg_in    
}

ocr_progress () {
    i=1
    while read -r line ; do
        if [[ "$line" =~ ^[P|p]age ]] ; then
            echo $(( i++ * 100 / image_count ))  >&"$progress_dlg_in"
            >&2 echo "$line"
        elif [[ "$line" == "" ]] ; then
            echo $(( i++ * 100 / image_count ))  >&"$progress_dlg_in"
        fi
    done
}

ocr_exec () {
    # ensure progress dialog is instantiated and active before piping to it
    start_progress_dialog
    local index
    while read -r f ; do
        bname=$(basename "$f")
        # shellcheck disable=SC2030
        index=${bname#"${job_settings[prefix]}-"}
        index=${index%%[-|\.]*}
        echo
        >&2 echo "$f"
        tmp_stem="${job_settings[output_dir]}/tmp/${job_settings[prefix]}-$index"            
        if [[ $configs2indi =~ .*txt ]] && \
                [ "${job_settings[ocr_layout]}" = "Column" ] ; then
            configs=${configs2indi//txt/}
            [[  $configs =~ .*pdf ]] && tmp_pdf="" || tmp_pdf="pdf"
            # shellcheck disable=SC2086
            tesseract "$f" "$tmp_stem" --psm 4 "$tmp_pdf" $configs
            stem_part="${job_settings[output_dir]}/documents/${job_settings[prefix]}"
            for f in "${job_settings[output_dir]}/tmp"/*.pdf ; do
                bname=$(basename "$f")
                index=${bname#"${job_settings[prefix]}-"}
                index=${index%%[-|\.]*}
                pdftotext -layout "$f" "$stem_part-$index.txt"
            done            
        else
            # shellcheck disable=SC2086
            tesseract "$f" "$tmp_stem" $configs2indi
        fi
    done | ocr_progress
    [[  $configs2indi =~ .*pdf ]] && convert_pdfs
    rm -f "${job_settings[output_dir]}/tmp"/*.pdf
}

ocr_exec_combine () {
    start_progress_dialog
    docs_dir="${job_settings[output_dir]}/documents"
    tmp_dir="${job_settings[output_dir]}/tmp"
    if [[ $configs2combi =~ .*txt ]] && \
        [ "${job_settings[ocr_layout]}" = "Column" ] ; then
        configs=${configs2combi//txt/}
        [[  $configs2combi =~ .*pdf ]] && tmp_pdf="" || tmp_pdf="pdf"
        if ! [[ $configs2combi =~ .*hocr ]] ; then
            tesseract - stdout --psm 4 pdf 2> >(ocr_progress) | \
                tee "$tmp_dir/${job_settings[prefix]}.pdf" | \
                    pdftotext -layout - "$docs_dir/${job_settings[prefix]}.txt"
        else 
            # shellcheck disable=SC2086
            tesseract - "$tmp_dir/${job_settings[prefix]}" \
                --psm 4 "$tmp_pdf" $configs 2> >(ocr_progress)
            mapfile -t pdf_files \
                < <(find "${job_settings[output_dir]}" -name "*.pdf" | sort -h)            
            for f in "${pdf_files[@]}" ; do
                cat "$f"
            done | pdftotext -layout - "$docs_dir/${job_settings[prefix]}.txt"
        fi
        ! [[  $configs2combi =~ .*pdf ]] && rm -f "$tmp_dir/"*.pdf
    else
        # shellcheck disable=SC2086
        tesseract - "$tmp_dir/${job_settings[prefix]}" \
            $configs2combi 2> >(ocr_progress)
    fi
    [[  $configs2combi =~ .*pdf ]] && convert_pdfs
    rm -f "$tmp_dir/"*.pdf
}

convert_pdfs () {
    mapfile -t pdf_files < <(find "${job_settings[output_dir]}/tmp" -name "*.pdf")
    for f in "${pdf_files[@]}" ; do
        >&2 echo -e "$f\nSetting page size to ${job_settings[page_size]}"
        >&2 gs -q -o "${job_settings[output_dir]}/documents/$(basename "$f")" \
            -sDEVICE=pdfwrite -sPAPERSIZE="${job_settings[page_size]}" \
            -dFIXEDMEDIA -dPDFFitPage -dCompatibilityLevel=1.4 "$f"
    done
}

build_options_dialog () {
    controls=(--add-combo="Rotation")
    cv=$(build_combo_values "-90|0|90" "${job_settings[rotation]}")
    controls+=(--combo-values="$cv")
    controls+=(--add-combo="Split pages")
    ${job_settings[split_pages]} && cv="Yes|No" || cv="No|Yes"
    controls+=(--combo-values="$cv")
    for opt in "${default_options_keys[@]}" ; do
        IFS=':' read -r _ type data _ label < <(echo "${default_options["$opt"]}")
        if [[ $label != "" ]] ; then
            case $type in
                "value"|"range")
                    controls+=(--add-entry="$label")
                ;;
                "list")
                    item=${scan_options["$opt"]}
                    cv=$(build_combo_values "$data" "$item")
                    controls+=(--add-combo="$label")
                    controls+=(--combo-values="$cv")
                ;;
            esac
        fi
    done
    controls+=(--add-combo="Save scan settings?")
    job="Only for this job"
    global="For all jobs"
    case ${job_settings[save_scan_settings]} in
        No*) cv="No|$job|$global" ;;
        Only*) cv="$job|$global|No" ;;
        For*) cv="$global|$job|No" ;;
    esac
    controls+=(--combo-values="$cv")
}

ui_show () {
    local options
    case $1 in
        "$DLG_SCANNER")
            # for the sake of Wayland and GDK_BACKEND=x11, prepare_dialog sends a
            # few do nothing keys to trigger the 'Allow Remote Interaction' dialog
            ( arrange_window zenity "$TITLE_BASE"; prepare_dialog ) &
            device_list=$(scanimage -f %m\|%t\|%d%n | tr '|' '\n' | zenity --list \
                --width=800 --height 400 \
                --title="$TITLE_BASE" --text="Select scanner:" \
                --column="Name" --column="Type" --column="Device" \
                --print-column=1,3 --cancel-label="Quit")
            if (( ! $? )) ; then
                name=${device_list%|*};device=${device_list#*|}
                echo "$DLG_FILESDIR" "$device|$name"
            else
                echo "$QUIT"
            fi
            ;;
        "$DLG_FILESDIR")
            arrange_window zenity "$TITLE_BASE" &
            value=$(zenity --file-selection --directory --filename="$HOME" \
                --title="$TITLE_BASE - Choose output folder")
            if (( ! $? )) ; then
                echo "$DLG_FILEBASE" "$value"
            else
                echo "$QUIT"
            fi
            ;;
        "$DLG_RESUME")
            title="$TITLE_BASE - Resume job"
            text1="Output folder: ${job_settings[output_dir]}\n\n"
            text2="Batch OCR found a previous job in this folder.\n"
            text3="Do you wish to resume it or wipe all files in this folder?\n\n"
            text4="Leave 'Index numbers start value' blank to resume at\n"
            text5="last value or enter a new value to overwrite any previous \n"
            text6="scans with this and successive index numbers.\n"
            arrange_window zenity "title" &
            value=$(zenity --forms --title="$title" \
                --text="$text1$text2$text3$text4$text5$text6" \
                --add-entry="Index numbers start value" \
                --cancel-label="Quit" --ok-label="Resume" \
                --extra-button="Wipe" --extra-button="Back")
            if (( ! $? )) ; then
                [ -z "$value" ] && value=-1
                echo "$DLG_READYQ" "$value"
            elif [ "$value" = "Wipe" ] ; then
                echo "$DLG_FILEBASE" "$value"
            elif [ "$value" = "Back" ] ; then
                echo "$DLG_FILESDIR"
            else
                echo "$QUIT"
            fi
            ;;
        "$DLG_FILEBASE")
            title="$TITLE_BASE - Output file options"
            ( arrange_window zenity "$title"; prepare_dialog "$1" "$title" ) &
            text1="  Edit and select options.\n\n"
            text2="  Filename with suffix examples:\n"
            text3="  scan-0001.tiff\n\  scan-0001-20250408-090316.jpeg\n"
            suffix_cvs=$(build_combo_values \
                            "Index number|Datetime and index number" \
                            "${job_settings[suffix]}")
            type_cvs=$(build_combo_values \
                        "tiff|jpeg|png|pnm" \
                        "${job_settings[images_type]}")
            pdf_cvs=$(build_combo_values \
                        "Individual PDFs|Combined PDF|None" \
                        "${job_settings[pdf_output]}")
            text_cvs=$(build_combo_values \
                        "Individual text files|Combined text file|None" \
                        "${job_settings[text_output]}")
            hocr_cvs=$(build_combo_values \
                        "Individual HOCR files|None" \
                        "${job_settings[hocr_output]}")
            layout_cvs=$(build_combo_values \
                            "Auto|Column" "${job_settings[ocr_layout]}")
            value=$(zenity --forms --title="$title" \
                --text="$text1$text2$text3" --separator=":" \
                --add-entry="Image file prefix                 " \
                --add-combo="Image file suffix" \
                --combo-values="$suffix_cvs" \
                --add-entry="Index numbers start value" \
                --add-combo="Image file type" \
                --combo-values="$type_cvs" \
                --add-combo="PDF output" \
                --combo-values="$pdf_cvs" \
                --add-combo="Text output" \
                --combo-values="$text_cvs" \
                --add-combo="HOCR output" \
                --combo-values="$hocr_cvs" \
                --add-combo="OCR language" \
                --combo-values="$(build_combo_langs)" \
                --add-combo="OCR layout mode" \
                --combo-values="$layout_cvs" \
                --add-combo="PDF page size" \
                --combo-values="$(build_combo_page_sizes)" \
                --cancel-label="Quit" --extra-button="Back")
            if (( ! $? )) ; then
                echo "$DLG_OPTIONS" "$value"
            elif [ "$value" = "Back" ] ; then
                echo "$DLG_FILESDIR"
            else
                echo "$QUIT"
            fi
            ;;
        "$DLG_OPTIONS")
            title="$TITLE_BASE - Options"
            declare -a controls
            build_options_dialog
            if ! $resume ; then
                next_dlg=$DLG_SCANNING
                ok_button="Scan"
            else
                next_dlg=$DLG_READYQ
                ok_button="OK"
            fi
            ( arrange_window zenity "$title"; prepare_dialog "$1" "$title" ) &
            value=$(zenity --forms --width=400 --separator=: --title="$title" \
                --text="Select or enter options as required." "${controls[@]}" \
                --cancel-label="Quit" --ok-label="$ok_button" --extra-button="Back")
            if (( ! $? )) ; then
                echo "$next_dlg" "$value"
            elif [ "$value" = "Back" ] ; then
                echo "$DLG_FILEBASE"
            else
                echo "$QUIT"
            fi
            ;;
        "$DLG_READYQ")
            title="$TITLE_BASE - Scan"
            ocr_option=""
            if $resume ; then
                ocr_option="--extra-button=OCR"
            fi
            arrange_window zenity "$title" &
            clicked=$(zenity --info --title="$title" --text="Ready to scan?" \
                --ok-label="Quit" --extra-button="Scan" \
                $ocr_option --extra-button="Back")
            case "$clicked" in
                Scan*)
                    echo "$DLG_SCANNING"
                    ;;
                Back)
                    echo "$DLG_OPTIONS"
                    ;;
                OCR)
                    echo "$DLG_OCR"
                    ;;
                *)
                    echo "$QUIT"
                    ;;
            esac
            ;;
        "$DLG_SCANNING")
            arrange_window zenity "$TITLE_BASE" &
            scanimage -n -d "$device" --format=pnm
            if (( $? )) ; then
                zenity --warning --width=400 --icon=dialog-warning \
                    --title="$TITLE_BASE" \
                    --text="Can't open device:\n\n$device\n \
                    \n- Is device connected?\n- Is device online? \
                    \n- Is network/WiFi available?" \
                    --ok-label="Try again"
                echo "$previous_stage"
            else
                arrange_window zenity "$TITLE_BASE" &
                scanimage -d "$device" "${scanimage_options[@]}" -p --format=pnm \
                    -o "${job_settings[output_dir]}"/tmp/scan.pnm |& tr '\r' '\n' | \
                    awk '/Progress:/ {
                        gsub(/%/, "", $2)
                        print $2
                        # only for test backend
                        system("sleep 0.002")
                    }' | zenity --progress --title="$TITLE_BASE" \
                        --text "Scanning" --percentage=0 --auto-close
                echo "$DLG_CONVERT" 
            fi
            ;;
        "$DLG_CONVERT")
            coproc convert_dlg { zenity --progress --pulsate \
                --no-cancel --auto-close \
                --title="$TITLE_BASE" \
                --text="Converting scan..." ; }
            arrange_window zenity "$TITLE_BASE"
            (( ${#magick_options[@]} )) &&
                $convert "${job_settings[output_dir]}"/tmp/scan.pnm "${magick_options[@]}" \
                    "${job_settings[output_dir]}"/tmp/scan.pnm
            read -r w h < <(identify -format "%w %h" \
                "${job_settings[output_dir]}"/tmp/scan.pnm)
            (( job_settings[rotation] )) && read -r w h <<<"$h $w"
            inc=$(( h / 10 + (h % 10 > 5) ))   
            for (( i=inc; i < h; i=i+inc )) ; do x_axes+=(-draw "line 0,$i,$w,$i") ; done
            inc=$(( w / 10 + (w % 10 > 5) ))   
            for (( i=inc; i < w; i=i+inc )) ; do y_axes+=(-draw "line $i,0,$i,$h") ; done
            $convert "${job_settings[output_dir]}"/tmp/scan.pnm \
                -rotate "${job_settings[rotation]}" -bordercolor red -border 2x2 \
                -stroke red -strokewidth 2 "${x_axes[@]}" "${y_axes[@]}" \
                "${job_settings[output_dir]}"/tmp/scan-grid.png
            echo 100  >&"${convert_dlg[1]}"
            $preview && echo "$UI_GRIDVIEW" || echo "$DLG_APPROVE"
            ;;
        "$UI_GRIDVIEW")
            eog --name=batch_ocr -w \
                "${job_settings[output_dir]}"/tmp/scan-grid.png &> /dev/null &
            arrange_window batch_ocr.Eog ""
            echo "$DLG_CROP"            
            ;;            
        "$DLG_CROP")
            title="$TITLE_BASE - Crop page"
            text="Enter the amounts to crop as percentages."
            if ${job_settings[split_pages]} ; then
                coproc crop_dlg { zenity --forms --separator=":" \
                    --title="${title}s" --text="$text"  \
                    --add-entry="Left page - left side" \
                    --add-entry="Left page - spine shadow" \
                    --add-entry="Right page - spine shadow" \
                    --add-entry="Right page - right side" \
                    --add-entry="Top" \
                    --add-entry="Bottom" \
                    --cancel-label="Quit" \
                    --extra-button="Back" ; }
            else
                coproc crop_dlg { zenity --forms --separator=":" \
                    --title="$title" --text="$text"  \
                    --add-entry="Left side" \
                    --add-entry="Right side" \
                    --add-entry="Top" \
                    --add-entry="Bottom" \
                    --cancel-label="Quit" \
                    --extra-button="Back" ; }
            fi
            arrange_window "zenity" "$title"
            [ "${job_settings[crop]}" != ":::::" ] && prepare_dialog "$1" "$title"
            read -r value <&"${crop_dlg[0]}"
            case "$value" in
                *:*)
                    echo "$DLG_APPROVE" "$value"
                    ;;
                Back)
                    wmctrl -x -c batch_ocr
                    echo "$DLG_READYQ"
                    ;;
                *)
                    wmctrl -x -c batch_ocr
                    echo "$QUIT"
                    ;;
            esac
            ;;
        "$DLG_APPROVE")
            infile="${job_settings[output_dir]}/tmp/scan.pnm"
            [[ ${job_settings[suffix]} =~ Datetime ]] &&
                datetime=$(printf '%(-%Y%m%d-%H%M%S)T\n' "$(stat -c %Y "$infile")") ||
                datetime=""
            # shellcheck disable=SC2031
            index1="-$(printf '%.3i\n' "$index")"
            # shellcheck disable=SC2031
            index2="-$(printf '%.3i\n' $((index + 1)))"
            path_and_prefix="${job_settings[output_dir]}/${job_settings[prefix]}"
            outfile1="$path_and_prefix$index1$datetime.${job_settings[images_type]}"
            outfile2="$path_and_prefix$index2$datetime.${job_settings[images_type]}"
            if ${job_settings[split_pages]} ; then
                if $resume ; then
                    rm -f "$path_and_prefix$index1"*.?(tiff|jpeg|png|pnm)
                    rm -f "$path_and_prefix$index2"*.?(tiff|jpeg|png|pnm)
                fi
                file=$(crop_pages "$infile" \
                    "$outfile1" "$outfile2" "${job_settings[rotation]}")
            else
                if $resume ; then
                    rm -f "$path_and_prefix$index1"*.?(tiff|jpeg|png|pnm)
                fi
                file=$(crop_page "$infile" "$outfile1" "${job_settings[rotation]}")
            fi
            eog -w --name=batch_ocr "$file" &> /dev/null &
            while ! wmctrl -x -a batch_ocr ; do sleep 0.1 ; done
            if $preview ; then
                b1=true;b2=false
            else
                b1=false;b2=true
            fi
            arrange_window zenity "$TITLE_BASE" &
            choice=$(zenity --list --radiolist --hide-header --title="$TITLE_BASE" \
                --text "Scan next or go back and try different crop values?" \
                --column="select" --column="preview" \
                $b1 "Preview next scan and set new crop values" \
                $b2 "Scan next and use last crop values" \
                --cancel-label="Quit" --ok-label="Scan" \
                --extra-button="Back" --extra-button="OCR")
            if [ "$choice" != "Back" ] ; then
                save_job_settings
                case ${job_settings[save_scan_settings]} in
                    Only*) save_scan_settings "${job_settings[output_dir]}" ;;
                    For*)
                        save_scan_settings "$bocr_dir"
                        save_scan_settings "${job_settings[output_dir]}"
                    ;;
                esac
            fi
            case "$choice" in
                Scan*)
                    echo "$DLG_SCANNING" false
                    ;;
                Preview*)
                    echo "$DLG_SCANNING" true
                    ;;
                Back*)
                    echo "$UI_GRIDVIEW"
                    ;;
                OCR*)
                    wmctrl -x -c batch_ocr
                    echo "$DLG_OCR"
                    ;;
                *)
                    wmctrl -x -c batch_ocr
                    echo "$QUIT"
                    ;;
            esac
            ;;
        "$DLG_OCR")
            mapfile -t image_files < <(find "${job_settings[output_dir]}" \
                -name "*.${job_settings[images_type]}" | sort -h)
            image_count=${#image_files[@]}
            for key in "${!job_settings[@]}"; do
                case ${job_settings[$key]} in
                    Individual*)
                        configs2indi+="${key%%_*} " ;;
                    Combined*)
                        configs2combi+="${key%%_*} " ;;
                esac
            done
            configs2indi=${configs2indi% }
            configs2combi=${configs2combi% }
            configs2indi_csv=${configs2indi/ /,}
            configs2indi_csv=${configs2indi_csv%,}
            configs2combi_csv=${configs2combi// /,}
            configs2combi_csv=${configs2combi_csv%,}
            configs2indi=${configs2indi/text/txt}
            configs2combi=${configs2combi/text/txt}
            doc="document"
            [[ $configs2combi_csv =~ .*, ]] && doc+=s
            text1="Processing $image_count image files for OCR"
            mkdir -p "${job_settings[output_dir]:?}/documents"
            if [ "$configs2indi" != "" ] ; then
                text2="to individual documents ($configs2indi_csv)"
                >&2 echo "$text1 $text2"
                for f in "${image_files[@]}" ; do
                    echo "$f"
                done | ocr_exec
            fi
            if [ "$configs2combi" != "" ] ; then
                text2="to combined $doc ($configs2combi_csv)"
                >&2 echo "$text1 $text2"
                for f in "${image_files[@]}" ; do
                    echo "$f"
                done | ocr_exec_combine
            fi
            mv -f "${job_settings[output_dir]}/tmp/"*.?(txt|hocr) \
                "${job_settings[output_dir]}/documents/" 2>/dev/null
            echo "$QUIT"
            ;;
        *) ;;
    esac
}

check_dependencies() {
    for d in \
        scanimage wmctrl xwininfo xprop xdotool zenity eog tesseract gs pdftotext
        do ! command -v "$d" >/dev/null 2>&1 && missing+="$d " ; done
    magick -version >/dev/null 2>&1 && convert="magick" || \
        convert -version >/dev/null 2>&1 && convert="convert" || \
        missing+="convert|magick"
    if [[ -v missing ]]; then
        echo -e "Missing dependencies:\n\n\t$missing\n"
        for pm in apt dnf yum pacman zypper rpm pkg xbps apk eopkg; do
            if command -v "$pm" >/dev/null 2>&1; then
                case "$pm" in
                    apt) pmc="sudo apt install" ;;
                    dnf) pmc="sudo dnf install" ;;
                    yum) pmc="sudo yum install" ;;
                    pacman) pmc="sudo pacman -S" ;;
                    zypper) pmc="sudo zypper install" ;;
                    rpm) pmc="sudo rpm --install" ;;
                    xbps) pmc="sudo xbps-install -S" ;;
                    apk) pmc="sudo apk add" ;;
                    eopkg) pmc="sudo eopkg install" ;;
                    pkg) pmc="sudo pkg install" ;;
                esac
                break
            fi
        done
        if [[ -v pmc ]]; then
            case "$pm" in
                pacman) pp="poppler" ;;
                zypper) pp="poppler-tools" ;;
                *) pp="poppler-utils" ;;
            esac
            for mc in $missing; do
                case "$mc" in
                    scanimage) pkgs+="sane " ;;
                    wmctrl) pkgs+="wmctrl " ;;
                    xwininfo) pkgs+="xwininfo " ;;
                    xprop) pkgs+="xprop " ;;
                    xdotool) pkgs+="xdotool " ;;
                    zenity) pkgs+="zenity " ;;
                    eog) pkgs+="eog " ;;
                    tesseract) pkgs+="tesseract-ocr " ;;
                    gs) pkgs+="ghostscript " ;;
                    pdftotext) pkgs+="$pp " ;;
                esac
            done
            echo "Suggested command to satisfy missing dependencies:"
            if [[ -v convert ]] ; then
                echo -e "\n\t$pmc $pkgs\n"
            else
                if [[ $missing != "convert|magick" ]]; then
                    echo -e "\n\t$pmc $pkgs\n\nFor convert|magick try:"
                fi
                echo -e "\n\t$pmc imagemagick\n\nor\n\t$pmc ImageMagick\n"
                echo -e "Notes:\n\n1. The first form is most common.\n"
                echo -en "2. Not all ImageMagickv7 builds provide the 'convert' alias "
                echo -en "for the 'magick' command,\n   so batch-ocr will call "
                echo -e "'convert' (v6) or 'magick' (v7).\n"
            fi
        else
            echo -n "Please refer to your distro's online package search and "
            echo -e "package manager documentation to satisfy these dependencies.\n"
        fi
        return 1
    else
        return 0
    fi
}

# declare stage constants or get constant name from stage value
# shellcheck disable=SC2120
translate_stages () {
    i=0
    for s in \
        QUIT \
        DLG_SCANNER \
        DLG_FILESDIR \
        DLG_RESUME \
        DLG_FILEBASE \
        DLG_OPTIONS \
        DLG_READYQ \
        DLG_SCANNING \
        DLG_CONVERT \
        UI_GRIDVIEW \
        DLG_CROP \
        DLG_APPROVE \
        DLG_OCR
    do
        if [ -z "$1" ] ; then
            declare -g $s=$i
        elif [ ${!s} = "$1" ] ; then
            echo $s
            break
        fi
        (( ++i ))
    done
}

print_debug_info () {
    echo -e "\n========== State after stage $(translate_stages "$stage") =========="
    for setting in "${!job_settings[@]}" ; do
        echo "Job setting: $setting -> ${job_settings[$setting]}"
    done
    for option in "${!default_options[@]}" ; do
        echo "Default option: $option -> $(get_scan_option "$option")"
    done
    for option in "${!scan_options[@]}" ; do
        echo "Scan option: $option -> ${scan_options[$option]}"
    done
    echo "---------- START Variables ----------"
    set | awk '/^[a-z].*=/ && !/^awk|default_options/ && !/^awk|job_settings/'
    echo "----------- END Variables -----------"
    echo -e "Next stage: $(translate_stages "$next_stage")\n"
}

pid=$$
c1=1
while true ; do
    pid=$(pgrep -f -P "$pid"  /bin/bash.*batch-ocr)
    (( $? )) && break
    (( c1++ ))
done
c2=$(pgrep -c -f "/bin/bash.*batch-ocr")
if (( --c2 > c1 )) ; then
    echo "Another instance is running, exiting"
    exit 1
fi
! check_dependencies && exit 2
translate_stages
bocr_path="${0}"
while [ -L "${bocr_path}" ] ; do 
    path="$(readlink "${bocr_path}")"
    [[ "${path}" == /* ]] && bocr_path="$path" || \
        bocr_path="$(dirname "${bocr_path}")/${path}"
done
bocr_dir="$(dirname "${bocr_path}")"
read -r working_area_x working_area_y working_area_width working_area_height \
    < <(wmctrl -d | awk -F'[/= ,x]' '{printf "%s %s %s %s\n", $13, $14, $15, $16; exit}')
working_area_centre_x=$((working_area_width / 2 + working_area_x))
working_area_centre_y=$((working_area_height / 2 + working_area_y))
ps=$(lpoptions -p "$(lpstat -d | awk -F': ' '{print $2}')" -l 2>/dev/null | \
        awk '/PageSize/ {for(i=1;i<=NF;i++) if ($i ~ /^\*/) \
            {gsub(/\*/, "", $i); print tolower($i)}}')
[ -n "$ps" ] && job_settings[page_size]=$ps
set_default_job_settings
stage=$DLG_SCANNER
while true; do
    read -r next_stage value < <(ui_show "$stage")
    if [ "$value" != "" ] ; then
        case $stage in
            "$DLG_SCANNER")
                device=${value%%|*}
                name=${value#*|}
                options=$(scanimage -A -d "$device" 2>/dev/null)
                if (( ! $? )) ; then
                    if ! [ -e "$bocr_dir/${device}.options" ] ; then
                        read_scan_options "=" \
                            < <(echo "$options" | awk "$awk_scanner_options" - )
                    else
                        read_scan_options ":" \
                            < <(cat "$bocr_dir/${device}.options" ; echo -e "\n")
                    fi
                else
                    arrange_window zenity "$TITLE_BASE" &
                    zenity --question --width=400 --icon=dialog-warning \
                        --title="$TITLE_BASE" \
                        --text="Can't open device:\n\n$device\n \
                        \nChoose another device or try again. \
                        \n\t- Is device connected?\n\t- Is device online? \
                        \n\t- Is network/WiFi available?" \
                        --cancel-label="Quit" --ok-label="Back"
                    (( ! $? )) && next_stage="$DLG_SCANNER" || next_stage="$QUIT"
                fi
                value=""
                ;;
            "$DLG_FILESDIR")
                if [ -e "$value/job-settings" ] ; then
                    fetch_job_settings "$value/job-settings"
                    last_scan_info="$(get_last_scan_info "$value")"
                    if [ -n "${last_scan_info%%:*}" ] ; then
                        next_stage="$DLG_RESUME"
                    fi
                fi
                fetch_scan_settings "$value"
                [ ! -e "$value/tmp" ] && mkdir "${value:?}/tmp"
                setting=output_dir
                ;;
            "$DLG_RESUME")
                if [ "$value" = "Wipe" ] ; then
                    title="$TITLE_BASE - Wipe folder"
                    text1="This will permanently delete any previously scanned "
                    text2="images and OCR'd documents from this folder.\n\n"
                    text3="Are you sure you want to proceed?"
                    ( arrange_window zenity "$title"; prepare_dialog "$1" ) &
                    zenity --question --width 350 --height 300 --default-cancel \
                        --icon dialog-warning --title "$title" \
                        --text "${job_settings[output_dir]}\n\n$text1$text2$text3"
                    (( ! $? )) && rm -fr "${job_settings[output_dir]:?}/"* || exit
                    set_default_job_settings
                    next_stage=$DLG_FILEBASE
                    n=1
                else
                    resume=true
                    scanimage_options=()
                    magick_options=()                    
                    for (( i=0; i < ${#default_options_keys[@]}; i++)) ; do
                        key="${default_options_keys[$i]}"
                        add_command_option "$key" "${scan_options["$key"]}"
                    done
                    if [ "$value" -le 0 ] ; then
                        last_scan_info="$(get_last_scan_info \
                                            "${job_settings[output_dir]}")"
                        n=${last_scan_info%%:*}
                    else
                        n=$(sanitise "$value")
                    fi
                    if ${job_settings[split_pages]} ; then
                        (( n % 2 == 0 )) && n=$(( n + 1 ))
                    fi
                fi
                [ ! -e "${job_settings[output_dir]}/tmp" ] && \
                    mkdir "${job_settings[output_dir]:?}/tmp"
                index=$n
                value=""
                ;;
            "$DLG_FILEBASE")
                IFS=':' read -r job_settings["prefix"] job_settings["suffix"] \
                    index job_settings["images_type"] job_settings["pdf_output"] \
                    job_settings["text_output"] job_settings["hocr_output"] \
                    job_settings["ocr_language"] job_settings["ocr_layout"] \
                    job_settings["page_size"] < <(echo "$value")
                value=""
                ;;
            "$DLG_OPTIONS")
                IFS=':' read -r -a opts <<< "$value"
                job_settings[rotation]=${opts[0]}
                job_settings[split_pages]=${opts[1]}
                job_settings[save_scan_settings]=${opts[${#opts[@]} - 1]}
                [ "${opts[1]}" = "Yes" ] && job_settings[split_pages]=true || \
                    job_settings[split_pages]=false
                scanimage_options=()
                magick_options=()
                for (( i=0, j=2; j < ${#opts[@]} - 1; i++, j++ )) ; do
                    key="${default_options_keys[$i]}"
                    scan_options["$key"]="${opts[$j]}"
                    add_command_option "$key" "${opts[$j]}"
                done
                value=""
                ;;
            "$DLG_CROP")
                setting=crop
                ;;
            "$DLG_APPROVE")
                if ${job_settings[split_pages]} ; then
                    index=$((index + 2))
                else
                    index=$((index + 1))
                fi
                preview=$value
                value=""
                ;;
        esac
        [ "$value" != "" ] && job_settings[$setting]="$value"
    fi
    [[ $BOCR_DEBUG = 1 ]] && print_debug_info
    if [ "$next_stage" = "$QUIT" ] ; then
        [[ $stage -gt $DLG_FILESDIR ]] && \
            rm -fr "${job_settings[output_dir]:?}/tmp"
        break
    fi
    previous_stage=$stage
    stage=$next_stage
done
